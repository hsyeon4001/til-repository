### 객체리터럴

---

#### 객체

- 다양한 타입의 값(원시 값 or 타 객체)을 하나의 단위로 구성한 복합적 자료구조.
- 원시 값과 달리 변경 가능한 값*mutable value*
- 0개 이상의 프로퍼티로 구성
  - 프로퍼티: 키와 값으로 구성. 객체의 상태를 나타내는 값
  - 자바스크립트의 모든 값은 프로퍼티 값이 될 수 있음
  - 프로퍼티 값이 함수일 경우 일반 함수와 구별하기 위해 메서드라고 부름
  - 메서드: 프로퍼티(상태 데이터)를 참조하고 조작할 수 있는 동작
- 프로퍼티와 메서드로 구성된 집합체
- 객체지향 프로그래밍: 객체의 집합으로 프로그램을 표현하려는 프로그래밍 방법

#### 객체 리터럴을 사용한 객체 생성

- 클래스 기반 객체지향 언어는 클래스를 사전에 정의하고 필요한 시점에 new 연산자와 함께 생성자를 호출해 인스턴스를 생성하는 방식으로 객체 생성
  - 인스턴스: 클래스에 의해 생성되어 메모리에 저장된 실체
  - 클래스: 인스턴스를 생성하기 위한 템플릿 역할
- 자바스크립트: 프로토타입 기반 객체지향으로 다양한 객체 생성 방법을 지원(ex: 객체 리터럴, Object 생성자 함수, 생성자 함수, Object.create 메서드, 클래스(ES6부터 지원))

#### 객체 리터럴

- 중괄호(`{}`)를 사용한 객체 표기법. 변수에 할당되는 시점에 자바스크립트 엔진은 객체 리터럴을 해석해 객체를 생성함
- 객체 리터럴은 값으로 표현되는 표현식 -> 중괄호가 코드블록을 의미하지 않으므로 세미콜론을 붙여야 함
- 객체 생성을 위해 클래스 정의와 생성자 호출이 필요하지 않으므로 편리함
- 객체 리터럴 외의 객체 생성 방법은 전부 함수 호출

#### 프로퍼티

- 프로퍼티 키: 프로퍼티 값에 접근하기 위한 이름(식별자 역할). 빈 문자열을 포함하는 모든 문자열 또는 심벌 값을 사용할 수 있지만 일반적으로 문자열 사용함
- 프로퍼티 값: 자바스크립트의 모든 값
- 프로퍼티 키 생성
  - 키는 문자열이므로 따옴표 사용해야 함. 식별자 네이밍 규칙에 맞으면 생략 가능
  - 대괄호를 사용해 키 동적 생성 가능
  - 키에 문자열이나 심벌 값 외의 값 사용 시 암묵적 타입 변환을 통해 문자열이 됨
  - 빈 문자열, 예약어도 사용 가능하지만 권장하지 않음
  - 키 중복 선언 시 나중 값이 덮어 씀

#### 메서드

- 함수는 값으로 취급할 수 있으므로 프로퍼티 값으로도 사용 가능함
- 메서드는 객체에 묶여 있는 함수라는 점에서 일반 함수와 다름

#### 프로퍼티 접근

- 접근 방법: 1) 마침표 표기법(`'`) 2) 대괄호 표기법(`[]`)
- 대괄호 표기법은 프로퍼티 키를 따옴표로 감싸야 함 -> 안하면 엔진이 식별자로 해석
  - 프로퍼티 키가 숫자로 이뤄진 문자열일 경우 생략 가능
  - 객체에 존재하지 않는 프로퍼티 접근 시 undefined 반환(에러 없이 무시됨)
- 이미 존재하는 프로퍼티에 값 할당 시 값이 갱신됨
- 존재하지 않는 프로퍼티에 값 할당 시 값이 동적 생성
- delete 연산자로 프로퍼티를 삭제할 수 있음. delete 연산자의 피연산자는 프로퍼티 값에 접근할 수 있는 표현식이어야 함.
  - 존재하지 않는 프로퍼티 삭제 시 무시됨

#### ES6의 객체 리터럴 확장 기능

- 프로퍼티 값으로 변수 사용 시 변수 이름과 키가 동일한 이름일 때 키 생략 가능함
- 객체 리터럴 내부에서 계산된 프로퍼티 이름으로 프로퍼티 키를 동적 생성할 수 있음
  - 계산된 프로퍼티 이름: 문자열이나 문자열로 타입 변환 가능한 값으로 평가되는 표현식을 사용해 프로퍼티 키를 동적 생성. 이때 표현식은 대괄호로 감싸야 함

```javascript
// ES5
var prefix = "prop";
var i = 0;
var obj = {};

obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;
obj[prefix + "-" + ++i] = i;

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
// ES6
const prefix = "prop";
let i = 0;

const obj = {
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
	[`${prefix}-${++i}`]: i,
};

console.log(obj); // {prop-1: 1, prop-2: 2, prop-3: 3}
```

- 메서드 축약 표현: 메서드 정의 시 function 키워드 생략 가능. 이렇게 정의된 메서드는 프로퍼티에 할당한 함수와 다르게 동작함

```javascript
// ES5
var obj = {
  sayHi: function() {
    console.log('hello world');
  }

// ES6
const obj = {
  sayHi() {
    console.log('hello world');
  }
}

}
```
