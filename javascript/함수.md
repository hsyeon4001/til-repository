### 함수

---

#### 함수란?

- 일련의 과정을 문으로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것
- 구성요소
  - 매개변수*parameter*: 입력을 전달받는 변수
  - 인수*arguemnt*: 입력
  - 반환값*return value*: 출력
- 함수 호출: 인수를 매개변수를 통해 함수에 전달하면서 함수의 실행을 명시적으로 지시

#### 함수를 사용하는 이유

- 코드의 중복을 억제하고 재사용성을 높임 -> 유지보수의 편의성을 높이고 실수를 줄여 코드의 신뢰성 상승

#### 함수 리터럴

- 함수는 객체 타입의 값이므로 리터럴을 통해 생성 가능함
- 구성요소: 함수이름, 매개변수 목록, 함수 몸체
- 일반 객체와의 차이: 일반 객체는 호출할 수 없지만 함수는 호출할 수 있음

#### 함수 정의

- 함수 정의: 함수를 호출하기 이전에 함수를 전달받을 매개변수와 실행할 문들, 반환한 값을 지정하는 것
- 함수 정의 방식: 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수

```javascript
// 함수 선언문
function add(x, y) {
	return x + y;
}

// 함수 표현식
var add = function (x, y) {
	return x + y;
};

// Function 생성자 함수
var add = new Function("x", "y", "return x + y");

// 화살표 함수
var add = (x, y) => x + y;
```

##### 1. 함수 선언문

- 함수 리터럴과 형태가 동일하나 함수 이름을 생략할 수 없다는 차이점이 있음
- 표현식이 아닌 문. -> 변수 할당 불가능

```javascript
var add = function add(x, y) {
	return x + y;
};

console.log(add(2, 5)); // 7
```

- 위 예제가 실행되는 이유는 자바스크립트 엔진이 코드 문맥에 따라 중의적 해석을 하기 때문. 함수는 함수 객체를 가리키는 식별자로 호출하므로 함수 이름 add가 아닌 변수명 add가 호출된 것
- 함수 선언문이 있을 경우 자바스크립트 엔진은 이를 해석해 함수 객체를 생성함. 이때 식별자가 없을 경우 암묵적으로 함수 이름과 동일한 이름의 식별자를 생성해 함수 객체를 할당함

##### 2. 함수 표현식

- 자바스크립트의 함수는 일급 객체 -> 값처럼 변수 할당, 프로퍼티나 배열에 사용 가능
  - 일급 객체: 값의 성질을 갖는 객체.
- 함수 표현식: 함수 리터럴로 생성한 함수 객체를 변수에 할당하는 함수 생성 방식
- 함수 표현식의 함수 리터럴은 함수 이름을 생략하는 것이 일반적

```javascript
var add = function (x, y) {
	return x + y;
};
```

##### 3. 함수 생성 시점과 함수 호이스팅

- 함수 선언문 vs. 함수 표현식
  - 함수 선언문은 표현식이 아닌 문, 함수 표현식은 표현식인 문
  - 함수 생성 시점이 다름. 함수 표현식은 함수 표현식 이전에 호출이 불가능함
  - 호이스팅: 함수 선언문이 코드의 선두로 끌어올려진 것처럼 동작하는 자바스크립트의 특징. 함수 선언문보다 위의 코드에서 해당 함수를 호출 가능함
  - 함수 호이스팅 vs. 변수 호이스팅: 함수 객체로 초기화 / undefined로 초기화
- 함수 표현식은 변수에 할당되는 값이 함수 리터럴인 문 -> 변수 선언문과 변수 할당문을 한 번에 기술한 축약 표현과 동일하게 동작함
  - 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가됨. 함수 표현식도 마찬가지 -> 함수 표현식은 변수 호이스팅이 발생(함수 호이스팅 X)
- 함수 표현식 이전에 함수를 참조하면 변수 선언문처럼 undefined로 평가되므로 이때의 함수 호출은 undefined 호출 -> 에러 발생

##### 5. Function 생성자 함수

- Function 생성자 함수: 빌트인 함수인 Function 생성자 함수를 사용해 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환. new 연산자는 생략 가능함
- Function 생성자 함수로 생성된 함수는 다른 생성 방식의 함수와 다르게 동작하므로 사용하지 않는 것이 바람직함

##### 화살표 함수

- function 키워드 대신 화살표를 사용한 함수 선언 방식. 항상 익명 함수로 함수를 정의함
- 생성자 함수로의 사용 불가능, this 바인딩 방식의 차이, prototype 프로퍼티 없음, arguments 객체를 생성하지 않는 등의 차이가 있음
